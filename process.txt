注: 项目中 注释 // - ****** 其中"-" 代表 改变 后将这行注释删除
一. 安装稳定版 node
二. 安装 webpack (建议本地安装)
  1. 特定版本 或者 指定版本
    npm install --save-dev webpack
    npm install --save-dev webpack@<version>
  2. webpack4+ 需要安装webpack-cli
    npm install --save-dev webpack-cli
  3. webpack 通过运行一个或多个 npm scripts，会在本地 node_modules 目录中查找安装的 webpack
三. 起步
  1. 基本安装
    (1). 创建webpac-demo目录并进入该文件夹: mkdir webpack-demo && cd webpack-demo
    (2). 初始化 npm: npm init -y
    (3). 本地安装 webpack及webpack-cli: npm install webpack webpack-cli --save-dev
    (4). 在 webpack-demo 目录下创建index.html: cd.>index.html
    (5). 在 webpack-demo 目录下创建 src 文件夹: md src
    (6). 在 webpack-demo/src 目录下创建index.js文件:cd src && cd.>index.js
    (7). 退至 webpack-demo 根目录: cd..
		(8). 使用 VScode 打开 webpack-demo 项目: code .
	2. 将 webpack-demo 加入版本控制
		(1). 初始化git仓库: git init
		(2). 配置忽略文件: 
			创建忽略文件: vim gitignore(进入vim模式)
			添加忽略规则: node_modules/ *.zip demo.html !src/ !index.html
			退出 vim 模式: 按 esc 输入:wq 点击回车
	3. 打开 src/index.js 添加如下代码
		(1). function component() {
						// 创建 div 元素
						let element = document.createElement('div')

						// lodash (目前在 index.html 中通过一个 script 脚本引入) 对于执行这一项必须的 
						element.innerHTML = _.join(['hello', 'webpack'], '')

						return element
					}
					document.body.appendChild(component())
		(2). 在 index.js 中引入 lodash 和 src/index.js
					<!DOCTYPE html>
					<html lang="en">
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1.0">
						<meta http-equiv="X-UA-Compatible" content="ie=edge">
						<title>起步</title>
						<script src="https://unpkg.com/lodash@4.16.6">
						</script>
					</head>
					<body>
						<script src='./src/index.js'>
						</script>
					</body>
					</html>
		(3). 调整 package.json 文件, 确保我们安装包是 私有的(private), 并且移除 main 入口, 防止意外发布代码
	4. 创建一个 bundle 文件
		(1). 调整目录结构
			在 webpack-demo 目录下新建 /dist/index.html 文件 删除 webpack/index.html 文件
		(2). 在 index.js 中 打包 lodash 依赖( 需在本地安装 library )
			npm install --save lodash
			注意: 安装一个用于打包到生产环境的安装包时，使用 npm install --save，
						安装一个用于开发环境的安装包（例如，linter, 测试库等），你应该使用 npm install --save-dev
		(3). 在 src/index.js 中 import lodash
				+ import _ from 'lodash';
				+
					function component() {
						var element = document.createElement('div');

				-   // Lodash, currently included via a script, is required for this line to work
				+   // Lodash, now imported by this script
						element.innerHTML = _.join(['Hello', 'webpack'], ' ');

						return element;
					}

					document.body.appendChild(component());
		(4). 更新 index.html
			由于现在通过 import 引入 lodash 所以将 dist/index.html 中 <script> 标签删除
			然后修改另一个 <script> 标签来加载 bundle 而不是原始的 /src 文件:
			dist/index.html
					<!doctype html>
					<html>
					 <head>
						 <title>起步</title>
				-    <script src="https://unpkg.com/lodash@4.16.6"></script>
					 </head>
					 <body>
				-    <script src="./src/index.js"></script>
				+    <script src="main.js"></script>
					 </body>
					</html>
		(5). 打包 webpack-demo 项目
			打开控制台
			执行 npx webpack 命令进行打包 
			在浏览器中打开 dist/index.html 文件, 看到 hello webpack 字样 说明打包成功
	5. 模块
		(1). webpack 支持 import 和 export 语句
		(2). webpack 不会更改代码中除 import 和 export 语句以外的部分
	6. 使用配置文件
		(1). 为什么使用配置
			项目会需求多样化和个性化,需要很复杂的配置,webpack 仍然要支持配置文件,比在终端手动输入大量命令更高效
		(2). 增加 webpack-demo/webpack.config.js 文件

			const path = require('path');

			module.exports = {
				entry: './src/index.js',
				output: {
					filename: 'bundle.js',
					path: path.resolve(__dirname, 'dist')
				}
			};
	7. 插播内容: 使用 git 作为版本控制 忘记 dist 加入忽略了 记录下已经在远程库的文件如何加入忽略
		1. git rm 与 git rm --cached 区别
			当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用
				git rm file_path
				git commit -m 'delete somefile'
				git push
			当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用
				git rm --cached file_path
				git commit -m 'delete remote somefile'
				git push
		2. 经过第一步聊解 使用以下 git 命令操作 删除远程 库中文件
			git rm -r --cached dist
			git commit -m "删除 dist 文件夹"
			git push origin master
		3. 将 dist 加入 .gitignore
			vi .gitignore (将进入 vim 文本编辑模式 会看到 .gitignore 中所有忽略文件规则)
			按 键盘 i 键 进入编辑状态 将光标 移动到最后一个 忽略规格 末尾 敲击回车 换行
			输入 dist/ 
			按 esc 退出编辑状态
			输入 :wq 保存 退出
			git add .gitignore 
			git commit -m "增加忽略文件 dist/")
			git push origin master
	8. webpack-demo/package.json 增加 build 脚本
		  {
					"name": "webpack-demo",
					"version": "1.0.0",
					"description": "",
					"main": "index.js",
					"scripts": {
						"test": "echo \"Error: no test specified\" && exit 1",
				+   "build": "webpack"
					},
					"keywords": [],
					"author": "",
					"license": "ISC",
					"devDependencies": {
						"webpack": "^4.0.1",
						"webpack-cli": "^2.0.9",
						"lodash": "^4.17.5"
					}
			}
	9. 使用 npm run build 命令重新打包项目
四. 管理资源
	1. 安装
		前期准备
			将dist/index.html中title更改为 资源管理(由于dist文件夹已加入git忽略所以git无法捕捉dist下文件更改)
	2. 加载 CSS
		(1). 安装 style-loader 和 css-loader
		(2). 为了从 JavaScript 模块中 import 一个 CSS 文件需要在 webpack.config.js 中配置 module 
				const path = require('path');

				module.exports = {
					entry: './src/index.js',
					output: {
						filename: 'bundle.js',
						path: path.resolve(__dirname, 'dist')
					},
			+   module: {
			+     rules: [
			+       {
			+         test: /\.css$/,
			+         use: [
			+           'style-loader',
			+           'css-loader'
			+         ]
			+       }
			+     ]
			+   }
				};
			webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。
			在这种情况下，以 .css 结尾的全部文件，都将被提供给 style-loader 和 css-loader。
		(3). 执行 npm run build 命令重新构建
	3. 加载 image
		(1). 安装 file-loader 处理图片
			npm install --save-dev file-loader
		(2). 修改 webpack.config.js 
					const path = require('path');

					module.exports = {
						entry: './src/index.js',
						output: {
							filename: 'bundle.js',
							path: path.resolve(__dirname, 'dist')
						},
						module: {
							rules: [
								{
									test: /\.css$/,
									use: [
										'style-loader',
										'css-loader'
									]
								},
				+       {
				+         test: /\.(png|svg|jpg|gif)$/,
				+         use: [
				+           'file-loader'
				+         ]
				+       }
							]
						}
					};
		(3). webpack-demo/src 添加 icon.png (图像任意)
		(4). 修改 webpack-demo/index.js 			
		  import _ from 'lodash';
				import './style.css';
			+ import Icon from './icon.png';

				function component() {
					var element = document.createElement('div');

					// Lodash，现在由此脚本导入
					element.innerHTML = _.join(['Hello', 'webpack'], ' ');
					element.classList.add('hello');

			+   // 将图像添加到我们现有的 div。
			+   var myIcon = new Image();
			+   myIcon.src = Icon;
			+
			+   element.appendChild(myIcon);

					return element;
				}

				document.body.appendChild(component());
		(5). 重新 build 项目
	4. 加载 字体
		注: file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。
				这就是说，我们可以将它们用于任何类型的文件，包括字体。
		(1). 添加字体文件 font.ttf 文件到src文件夹下 可以在 https://github.com/GleasonBian/webpack-demo 下载
		(2). webpack.config.js
					const path = require('path');

					module.exports = {
						entry: './src/index.js',
						output: {
							filename: 'bundle.js',
							path: path.resolve(__dirname, 'dist')
						},
						module: {
							rules: [
								{
									test: /\.css$/,
									use: [
										'style-loader',
										'css-loader'
									]
								},
								{
									test: /\.(png|svg|jpg|gif)$/,
									use: [
										'file-loader'
									]
								},
				+       {
				+         test: /\.(woff|woff2|eot|ttf|otf)$/,
				+         use: [
				+           'file-loader'
				+         ]
				+       }
							]
						}
					};
		(3). src/style.css
			+ @font-face {
			+   font-family: 'MyFont';
			+   src:  url('./my-font.woff2') format('woff2'),
			+         url('./my-font.woff') format('woff');
			+   font-weight: 600;
			+   font-style: normal;
			+ }

				.hello {
					color: red;
			+   font-family: 'MyFont';
					background: url('./icon.png');
				}
		(4). 执行 npm run build 打包
	5. 加载数据
		加载数据如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，
		也就是说 import Data from './data.json' 默认将正常运行。
		要导入 CSV、TSV 和 XML，可以使用 csv-loader 和 xml-loader 处理这三类文件
		(1). 安装 解析csv xml loader 解析插件
			npm install --save-dev csv-loader xml-loader
		(2). 配置 webpack.config.js 
					const path = require('path');

					module.exports = {
						entry: './src/index.js',
						output: {
							filename: 'bundle.js',
							path: path.resolve(__dirname, 'dist')
						},
						module: {
							rules: [
								{
									test: /\.css$/,
									use: [
										'style-loader',
										'css-loader'
									]
								},
								{
									test: /\.(png|svg|jpg|gif)$/,
									use: [
										'file-loader'
									]
								},
								{
									test: /\.(woff|woff2|eot|ttf|otf)$/,
									use: [
										'file-loader'
									]
								},
				+       {
				+         test: /\.(csv|tsv)$/,
				+         use: [
				+           'csv-loader'
				+         ]
				+       },
				+       {
				+         test: /\.xml$/,
				+         use: [
				+           'xml-loader'
				+         ]
				+       }
							]
						}
					};
		(3). 增加 src/data.xml 文件
				<?xml version="1.0" encoding="UTF-8"?>
				<note>
					<to>Mary</to>
					<from>John</from>
					<heading>Reminder</heading>
					<body>Call Cindy on Tuesday</body>
				</note>
		(4). src/index.js
			  import _ from 'lodash';
					import './style.css';
					import Icon from './icon.png';
				+ import Data from './data.xml';

					function component() {
						var element = document.createElement('div');

						// Lodash, now imported by this script
						element.innerHTML = _.join(['Hello', 'webpack'], ' ');
						element.classList.add('hello');

						// Add the image to our existing div.
						var myIcon = new Image();
						myIcon.src = Icon;

						element.appendChild(myIcon);

				+   console.log(Data);

						return element;
					}

					document.body.appendChild(component());
	6. 回退处理 (为管理输入做准备)
			webpack-demo
				|- package.json
				|- webpack.config.js
				|- /dist
					|- bundle.js
					|- index.html
				|- /src
				-   |- data.xml
				-   |- my-font.woff
				-   |- my-font.woff2
				-   |- icon.png
				-   |- style.css
						|- index.js
					|- /node_modules
			webpack.config.js	
				const path = require('path');

				module.exports = {
					entry: './src/index.js',
					output: {
						filename: 'bundle.js',
						path: path.resolve(__dirname, 'dist')
					},
				-   module: {
				-     rules: [
				-       {
				-         test: /\.css$/,
				-         use: [
				-           'style-loader',
				-           'css-loader'
				-         ]
				-       },
				-       {
				-         test: /\.(png|svg|jpg|gif)$/,
				-         use: [
				-           'file-loader'
				-         ]
				-       },
				-       {
				-         test: /\.(woff|woff2|eot|ttf|otf)$/,
				-         use: [
				-           'file-loader'
				-         ]
				-       },
				-       {
				-         test: /\.(csv|tsv)$/,
				-         use: [
				-           'csv-loader'
				-         ]
				-       },
				-       {
				-         test: /\.xml$/,
				-         use: [
				-           'xml-loader'
				-         ]
				-       }
				-     ]
				-   }
					};
			src/index.js

				import _ from 'lodash';
				- import './style.css';
				- import Icon from './icon.png';
				- import Data from './data.xml';
				-
					function component() {
						var element = document.createElement('div');
				-
				-   // Lodash，现在通过 script 标签导入
						element.innerHTML = _.join(['Hello', 'webpack'], ' ');
				-   element.classList.add('hello');
				-
				-   // 将图像添加到我们已有的 div 中。
				-   var myIcon = new Image();
				-   myIcon.src = Icon;
				-
				-   element.appendChild(myIcon);
				-
				-   console.log(Data);

						return element;
					}

				document.body.appendChild(component());
五. 管理输出
	(1). 增加 src/prinit.js
		export default function printMe() {
			console.log('I get called from print.js!');
		}
	(2). 在 src/index.js 中使用 printMe 函数
				import _ from 'lodash';
			+ import printMe from './print.js';

				function component() {
					var element = document.createElement('div');
			+   var btn = document.createElement('button');

					element.innerHTML = _.join(['Hello', 'webpack'], ' ');

			+   btn.innerHTML = 'Click me and check the console!';
			+   btn.onclick = printMe;
			+
			+   element.appendChild(btn);

					return element;
				}

				document.body.appendChild(component());
	(3). 更新 dist/index.html 文件为 webpack 分离入口做好准备
				import _ from 'lodash';
			+ import printMe from './print.js';

				function component() {
					var element = document.createElement('div');
			+   var btn = document.createElement('button');

					element.innerHTML = _.join(['Hello', 'webpack'], ' ');

			+   btn.innerHTML = 'Click me and check the console!';
			+   btn.onclick = printMe;
			+
			+   element.appendChild(btn);

					return element;
				}

				document.body.appendChild(component());
	(4). 现在调整配置。我们将在 entry 添加 src/print.js 作为新的入口起点（print），
			 然后修改 output，以便根据入口起点名称动态生成 bundle 名称
			webpack.config.js
					const path = require('path');

					module.exports = {
				-   entry: './src/index.js',
				+   entry: {
				+     app: './src/index.js',
				+     print: './src/print.js'
				+   },
						output: {
				-     filename: 'bundle.js',
				+     filename: '[name].bundle.js',
							path: path.resolve(__dirname, 'dist')
						}
					};
	(5). 执行 npm run build 浏览器运行 dist/index.html 查看运行效果
	(6). 问题:
					webpack 生成 print.bundle.js 和 app.bundle.js 文件，这也和我们在 index.html 文件中指定的文件名称相对应。
					但是，如果我们更改了我们的一个入口起点的名称，甚至添加了一个新的名称，
					生成的包将被重命名在一个构建中，然而 index.html 文件仍然会引用旧的名字。
			 解决: 
					使用 HtmlWebpackPlugin 来解决这个问题。
	(7). 安装htmlWebpackPlugin 
		安装 html-webpack-plugin 插件 npm install --save-dev html-webpack-plugin 
	(8). 配置 webpack.config.js
				const path = require('path');
			+ const HtmlWebpackPlugin = require('html-webpack-plugin');

				module.exports = {
					entry: {
						app: './src/index.js',
						print: './src/print.js'
					},
			+   plugins: [
			+     new HtmlWebpackPlugin({
			+       title: 'Output Management'
			+     })
			+   ],
					output: {
						filename: '[name].bundle.js',
						path: path.resolve(__dirname, 'dist')
					}
				};
	(10). 清理 /dist 文件夹
		安装 clean-webpack-plugin 插件 
				npm install clean-webpack-plugin --save-dev
		更新 webpack.config.js 配置
					const path = require('path');
					const HtmlWebpackPlugin = require('html-webpack-plugin');
				+ const CleanWebpackPlugin = require('clean-webpack-plugin');

					module.exports = {
						entry: {
							app: './src/index.js',
							print: './src/print.js'
						},
						plugins: [
				+     new CleanWebpackPlugin(['dist']),
							new HtmlWebpackPlugin({
								title: 'Output Management'
							})
						],
						output: {
							filename: '[name].bundle.js',
							path: path.resolve(__dirname, 'dist')
						}
					};
			const path = require('path');
			const HtmlWebpackPlugin = require('html-webpack-plugin');
			const CleanWebpackPlugin = require('clean-webpack-plugin');

			module.exports = {
				entry: {
					app: './src/index.js',
					print: './src/print.js'
				}
				plugins: [
					new CleanWebpackPlugin(),  // 这里需要注意 clean-webpack-plugin^2.0.1版本中 new CleanWebpackPlugin(['dist']) 写法不支持, 默认会清理 output 中定义的文件夹 更省事了
					new HtmlWebpackPlugin({
						title: 'Development'
					})
				],
				output: {
					filename: '[name].bundle.js',
					path: path.resolve(__dirname, 'dist')
				}
			};
六. 开发
	(1). 使用 source map 追踪错误和警告
		作用: 将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。
		配置 inline-source-map 选项 (不要用于生产环境)
		webpack.config.js

			const path = require('path');
				const HtmlWebpackPlugin = require('html-webpack-plugin');
				const CleanWebpackPlugin = require('clean-webpack-plugin');

				module.exports = {
					entry: {
						app: './src/index.js',
						print: './src/print.js'
					},
			+   devtool: 'inline-source-map',
					plugins: [
						new CleanWebpackPlugin(['dist']),
						new HtmlWebpackPlugin({
							title: 'Development'
						})
					],
					output: {
						filename: '[name].bundle.js',
						path: path.resolve(__dirname, 'dist')
					}
				};
	(2). 在 print.js 文件中生成一个错误
		src/print.js
				export default function printMe() {
			-   console.log('I get called from print.js!');
			+   cosnole.error('I get called from print.js!');
				}
	(3). 运行 npm run build 命令 打开控制台 查看
		Uncaught ReferenceError: cosnole is not defined
    at HTMLButtonElement.e (print.js:4)
		错误原因: Uncaught ReferenceError: cosnole is not defined at HTMLButtonElement.e
		错误位置: (print.js:4) 错误位置在 print.js 文件的第四行
	(4). 使用观察模式
		1. 在 package.json 添加一个用于启动 webpack 的观察模式的 npm script 脚本
				{
					"name": "development",
					"version": "1.0.0",
					"description": "",
					"main": "webpack.config.js",
					"scripts": {
						"test": "echo \"Error: no test specified\" && exit 1",
			+     "watch": "webpack --watch",
						"build": "webpack"
					},
					"keywords": [],
					"author": "",
					"license": "ISC",
					"devDependencies": {
						"clean-webpack-plugin": "^0.1.16",
						"css-loader": "^0.28.4",
						"csv-loader": "^2.1.1",
						"file-loader": "^0.11.2",
						"html-webpack-plugin": "^2.29.0",
						"style-loader": "^0.18.2",
						"webpack": "^3.0.0",
						"xml-loader": "^1.2.1"
					}
				}
		2. 执行 npm run watch 命令 观察控制台
	(5). 使用 webpack-dev-server
		1. 作用: webpack-dev-server 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。
		2. 安装: npm install --save-dev webpack-dev-server
		3. 更行 webpack.config.js 配置
					const path = require('path');
					const HtmlWebpackPlugin = require('html-webpack-plugin');
					const CleanWebpackPlugin = require('clean-webpack-plugin');

					module.exports = {
						entry: {
							app: './src/index.js',
							print: './src/print.js'
						},
						devtool: 'inline-source-map',
				+   devServer: {
				+     contentBase: './dist'
				+   },
						plugins: [
							new CleanWebpackPlugin(['dist']),
							new HtmlWebpackPlugin({
								title: 'Development'
							})
						],
						output: {
							filename: '[name].bundle.js',
							path: path.resolve(__dirname, 'dist')
						}
					};
		4. 更新 package.json 配置
				{
					"name": "development",
					"version": "1.0.0",
					"description": "",
					"main": "webpack.config.js",
					"scripts": {
						"test": "echo \"Error: no test specified\" && exit 1",
						"watch": "webpack --watch",
			+     "start": "webpack-dev-server --open",
						"build": "webpack"
					},
					"keywords": [],
					"author": "",
					"license": "ISC",
					"devDependencies": {
						"clean-webpack-plugin": "^0.1.16",
						"css-loader": "^0.28.4",
						"csv-loader": "^2.1.1",
						"file-loader": "^0.11.2",
						"html-webpack-plugin": "^2.29.0",
						"style-loader": "^0.18.2",
						"webpack": "^3.0.0",
						"xml-loader": "^1.2.1"
					}
				}
		5. 执行 npm start 命令 
			浏览器自动加载页面, 如果修改 和 保存任意源文件 web 服务器就会自动重新加载编译后的代码
		5. webpack-dev-server 更多配置文档
				https://www.webpackjs.com/configuration/dev-server/	












			

